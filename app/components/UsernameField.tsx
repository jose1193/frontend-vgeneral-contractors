import React, { useState, useRef, useCallback, useEffect } from "react";
import { Field, FieldProps } from "formik";
import { TextField, CircularProgress, Typography } from "@mui/material";
import { checkUsernameAvailable } from "../lib/api";
import { useSession } from "next-auth/react";

interface UsernameFieldProps {
  field: any;
  form: any;
  autoGenerated?: string;
  onManualChange?: () => void;
}

interface UsernameResponse {
  success: boolean;
  data: {
    available: boolean;
    message: string;
  };
  message: number;
}

const UsernameField: React.FC<UsernameFieldProps> = ({
  field,
  form,
  autoGenerated,
  onManualChange,
}) => {
  const [usernameAvailability, setUsernameAvailability] = useState<
    boolean | null
  >(null);
  const [isCheckingUsername, setIsCheckingUsername] = useState(false);
  const [debouncedUsername, setDebouncedUsername] = useState("");
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const [isFirstAutoGeneration, setIsFirstAutoGeneration] = useState(true);
  const textFieldRef = useRef<HTMLInputElement>(null);

  const { data: session } = useSession();

  // Handle auto-generated username
  useEffect(() => {
    if (autoGenerated && isFirstAutoGeneration) {
      form.setFieldValue("username", autoGenerated);
      setDebouncedUsername(autoGenerated);
      setIsFirstAutoGeneration(false);

      if (textFieldRef.current) {
        const nativeInput = textFieldRef.current.querySelector("input");
        if (nativeInput) {
          nativeInput.value = autoGenerated;
          nativeInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
      }
    }
  }, [autoGenerated, form, isFirstAutoGeneration]);

  const handleUsernameChange = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const username = event.target.value;
      form.setFieldValue("username", username);

      if (onManualChange) {
        onManualChange();
      }

      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }

      debounceTimerRef.current = setTimeout(() => {
        setDebouncedUsername(username);
      }, 300);
    },
    [form, onManualChange]
  );

  useEffect(() => {
    const checkUsername = async () => {
      if (!debouncedUsername) {
        setUsernameAvailability(null);
        setErrorMessage(null);
        return;
      }

      setIsCheckingUsername(true);
      setErrorMessage(null);
      try {
        const response = await checkUsernameAvailable(
          session?.accessToken as string,
          debouncedUsername
        );

        setUsernameAvailability(response.data.available);
        if (!response.data.available) {
          setErrorMessage(response.data.message);
        }
      } catch (error) {
        console.error("Failed to check username availability", error);
        setUsernameAvailability(null);
        if (error instanceof Error) {
          setErrorMessage(error.message);
        } else {
          setErrorMessage("An unknown error occurred");
        }
      } finally {
        setIsCheckingUsername(false);
      }
    };

    checkUsername();
  }, [debouncedUsername, session?.accessToken]);

  const getHelperTextStyle = () => {
    if (usernameAvailability === true) {
      return { color: "#2e7d32" }; // Verde de Material-UI success
    } else if (usernameAvailability === false || errorMessage) {
      return { color: "#d32f2f" }; // Rojo de Material-UI error
    }
    return {};
  };

  const getHelperText = () => {
    if (errorMessage) {
      return errorMessage;
    } else if (usernameAvailability === true) {
      return "Username is available ✓";
    } else if (usernameAvailability === false) {
      return "Username is already taken ✗";
    }
    return "";
  };

  return (
    <div className="relative w-full">
      <TextField
        {...field}
        fullWidth
        label="Username"
        variant="outlined"
        ref={textFieldRef}
        onChange={handleUsernameChange}
        error={
          !!(form.touched.username && form.errors.username) ||
          !!errorMessage ||
          usernameAvailability === false
        }
        helperText={
          <div className="flex items-center gap-2 mt-1">
            {isCheckingUsername ? (
              <div className="flex items-center gap-2">
                <CircularProgress size={16} />
                <span>Checking availability...</span>
              </div>
            ) : (
              <span style={getHelperTextStyle()}>
                {(form.touched.username && form.errors.username) ||
                  getHelperText()}
              </span>
            )}
          </div>
        }
        InputProps={{
          style: {
            borderColor: usernameAvailability === true ? "#2e7d32" : undefined,
          },
        }}
        InputLabelProps={{
          shrink: true,
        }}
      />
    </div>
  );
};

export default UsernameField;
