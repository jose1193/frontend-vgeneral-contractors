import React, { useState, useRef, useCallback, useEffect } from "react";
import { TextField, CircularProgress, Typography } from "@mui/material";
import { checkUsernameAvailable } from "../lib/api";
import { useSession } from "next-auth/react";
import { Controller, useFormContext } from "react-hook-form";

interface UsernameFieldProps {
  autoGenerated?: string;
  onManualChange?: () => void;
}

interface UsernameResponse {
  success: boolean;
  data: {
    available: boolean;
    message: string;
  };
  message: number;
}

const UsernameField: React.FC<UsernameFieldProps> = ({
  autoGenerated,
  onManualChange,
}) => {
  const [usernameAvailability, setUsernameAvailability] = useState<
    boolean | null
  >(null);
  const [isCheckingUsername, setIsCheckingUsername] = useState(false);
  const [debouncedUsername, setDebouncedUsername] = useState("");
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const [isFirstAutoGeneration, setIsFirstAutoGeneration] = useState(true);
  const textFieldRef = useRef<HTMLInputElement>(null);

  const { data: session } = useSession();
  const { control, setValue, trigger } = useFormContext();

  // Handle auto-generated username
  useEffect(() => {
    if (autoGenerated && isFirstAutoGeneration) {
      setValue("username", autoGenerated, { shouldValidate: true });
      setDebouncedUsername(autoGenerated);
      setIsFirstAutoGeneration(false);

      if (textFieldRef.current) {
        const nativeInput = textFieldRef.current.querySelector("input");
        if (nativeInput) {
          nativeInput.value = autoGenerated;
          nativeInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
      }

      trigger("username");
    }
  }, [autoGenerated, setValue, isFirstAutoGeneration, trigger]);

  const handleUsernameChange = useCallback((username: string) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    debounceTimerRef.current = setTimeout(() => {
      setDebouncedUsername(username);
    }, 300);
  }, []);

  useEffect(() => {
    const checkUsername = async () => {
      if (!debouncedUsername) {
        setUsernameAvailability(null);
        setErrorMessage(null);
        return;
      }

      setIsCheckingUsername(true);
      setErrorMessage(null);
      try {
        const response = await checkUsernameAvailable(
          session?.accessToken as string,
          debouncedUsername
        );

        setUsernameAvailability(response.data.available);
        if (!response.data.available) {
          setErrorMessage(response.data.message);
        }
      } catch (error) {
        console.error("Failed to check username availability", error);
        setUsernameAvailability(null);
        if (error instanceof Error) {
          setErrorMessage(error.message);
        } else {
          setErrorMessage("An unknown error occurred");
        }
      } finally {
        setIsCheckingUsername(false);
      }
    };

    checkUsername();
  }, [debouncedUsername, session?.accessToken]);

  const getHelperTextStyle = () => {
    if (usernameAvailability === true) {
      return { color: "#2e7d32" }; // Verde de Material-UI success
    } else if (usernameAvailability === false || errorMessage) {
      return { color: "#d32f2f" }; // Rojo de Material-UI error
    }
    return {};
  };

  const getHelperText = () => {
    if (errorMessage) {
      return errorMessage;
    } else if (usernameAvailability === true) {
      return "Username is available ✓";
    } else if (usernameAvailability === false) {
      return "Username is already taken ✗";
    }
    return "";
  };

  return (
    <Controller
      name="username"
      control={control}
      rules={{
        required: "Username is required",
        minLength: {
          value: 3,
          message: "Username must be at least 3 characters long",
        },
        pattern: {
          value: /^[a-zA-Z0-9_]+$/,
          message:
            "Username can only contain letters, numbers, and underscores",
        },
      }}
      render={({
        field: { onChange, value, ...restField },
        fieldState: { error },
      }) => (
        <div className="relative w-full">
          <TextField
            {...restField}
            value={value || ""}
            fullWidth
            label="Username"
            variant="outlined"
            ref={textFieldRef}
            onChange={(e) => {
              onChange(e);
              handleUsernameChange(e.target.value);
              if (onManualChange) {
                onManualChange();
              }
            }}
            error={!!error || !!errorMessage || usernameAvailability === false}
            helperText={
              <div className="flex items-center gap-2 mt-1">
                {isCheckingUsername ? (
                  <div className="flex items-center gap-2">
                    <CircularProgress size={16} />
                    <span>Checking availability...</span>
                  </div>
                ) : (
                  <span style={getHelperTextStyle()}>
                    {error?.message || getHelperText()}
                  </span>
                )}
              </div>
            }
            InputProps={{
              style: {
                borderColor:
                  usernameAvailability === true ? "#2e7d32" : undefined,
              },
            }}
            InputLabelProps={{
              shrink: true,
            }}
          />
        </div>
      )}
    />
  );
};

export default UsernameField;
